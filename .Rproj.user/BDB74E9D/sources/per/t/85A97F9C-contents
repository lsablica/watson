// [[Rcpp::depends(RcppGSL)]]
// [[Rcpp::depends(RcppArmadillo)]]
#include <RcppArmadillo.h>
#include <RcppGSL.h>
#include <gsl/gsl_sf_hyperg.h>
#include <RcppArmadilloExtensions/sample.h>
using namespace Rcpp;

arma::mat rwat(int n, double kappa, arma::vec &mu, double b = -10){
   double norm = as_scalar(sum(pow(mu,2)));
   int p = mu.n_elem;
   arma::mat A(n, p); 
   if(kappa == 0 || norm == 0){/*uniform*/
      return normalise(A.randn(),2,1);
   }
   mu = mu/sqrt(norm);
   int count = 0;
   int Nt = 0;
   double cand, unif;
   arma::rowvec candidate, cand2,ratio;
   if(kappa<0){
      if(b<0) b = 0.5*(p+2*kappa+sqrt(p*p+4*kappa*(kappa+2)-4*p*kappa));
      // Rcout << "b:" << b << std::endl;
      double known = -p*0.5*(log(p)-log(b)) + 0.5 * (p-b);
      double scale = b/(b-2*kappa);
      while(count<n){
         if (Nt % 10000 == 0) Rcpp::checkUserInterrupt();
         candidate = arma::randn(p).t();
         candidate(p-1) *= sqrt(scale);
         candidate = normalise(candidate);
         cand = candidate(p-1);
         cand2 = resize(candidate, 1, p-1);
         unif = arma::randu<double>();
         ratio = cand*cand*kappa + known + p*0.5*log(sum(pow(cand2,2),1) + cand*cand/scale);
         if(log(unif)<ratio(0)){
            A.row(count) = candidate;
            count += 1;
         }
         Nt += 1;
      }
   } else{
      if(b<0) b = 0.5*(p-2*kappa+sqrt(pow(p,2)+4*pow(kappa,2)-4*(p-2)*kappa));
      // Rcout << "b:" << b  << std::endl;
      double scale = b/(b+2*kappa);
      double known = -p*0.5*(log(p)-log(b)) + 0.5 * (p-b);
      while(count<n){
         if (Nt % 10000 == 0) Rcpp::checkUserInterrupt();
         candidate = arma::randn(p).t();
         candidate.subvec( 0, p-2 ) *= sqrt(scale);
         candidate = arma::normalise(candidate);
         cand = candidate(p-1);
         cand2 = resize(candidate,1 ,p-1);
         unif = arma::randu<double>();
         ratio = known - sum(pow(cand2,2),1)*kappa + p*0.5*log(sum(pow(cand2,2),1)/scale+cand*cand);
         if(log(unif)<ratio(0)){
            A.row(count) = candidate;
            count += 1;
         }
         Nt += 1;
      }
   }
   arma::mat Q,R;
   qr(Q,R,mu);
   A = A*join_rows(Q.cols(1, p-1),mu).t();
   double ans = (double)n / (double)Nt;
   Rcout << n <<"/" << Nt << "=" << ans << "% accepted." << std::endl;
   return A;
}
// [[Rcpp::export]]
NumericMatrix rmwat(int n, arma::vec weights, arma::vec kappa, arma::mat mu, double b = -10){
  weights = arma::normalise(weights, 1);
  int p = mu.n_rows;
  int K = mu.n_cols;
  arma::mat A(n, p);
  arma::uvec sample = RcppArmadillo::sample(arma::regspace<arma::uvec>(0, K-1), n, true, weights);
  int size;
  arma::uvec which;
  arma::vec mus;
  for(int i = 0; i < K; i++) {
    which = arma::find(sample==i);
    size = which.n_elem; 
    // Rcout << size << std::endl;
    mus = mu.col(i);
    if(size>0){
      A.rows(which) = rwat(size, kappa(i), mus, b);
    }
  }
  sample = sample + 1;
  IntegerVector fac = wrap(sample);
  IntegerVector lev = seq(1,K); 
  fac.attr("dim") = R_NilValue;
  fac.attr("levels") = as<CharacterVector>(lev);
  fac.attr("class") = "factor";
  
  NumericMatrix res = wrap(A);
  res.attr("id") = fac;
  res.attr("class") = "rmwat";
  return res;
}