#include <RcppArmadillo.h>
#include <RcppArmadilloExtensions/sample.h>
using namespace Rcpp;

arma::mat rwat(int n, double kappa, arma::vec &mu, double b = -10){
  double norm = as_scalar(sum(pow(mu,2)));
  int p = mu.n_elem;
  arma::mat A(n, p);
  if(kappa == 0 || norm == 0){/*uniform*/
    return normalise(A.randn(),2,1);
  }
  mu = mu/sqrt(norm);
  int count = 0;
  int Nt = 0;
  double cand, unif;
  arma::rowvec candidate, cand2,ratio;
  if(kappa<0){
    if(b<=0) b = 0.5*(p+2*kappa+sqrt(p*p+4*kappa*(kappa+2)-4*p*kappa));
    // Rcout << "b:" << b << std::endl;
    double known = -p*0.5*(log(p)-log(b)) + 0.5 * (p-b);
    double scale = b/(b-2*kappa);
    while(count<n){
      candidate = arma::randn(p).t();
      candidate(p-1) *= sqrt(scale);
      candidate = normalise(candidate);
      cand = candidate(p-1);
      cand2 = resize(candidate, 1, p-1);
      unif = arma::randu<double>();
      ratio = cand*cand*kappa + known + p*0.5*log(sum(pow(cand2,2),1) + cand*cand/scale);
      if(log(unif)<ratio(0)){
        A.row(count) = candidate;
        count += 1;
      }
      Nt += 1;
    }
  } else{
    if(b<=0) b = 0.5*(p-2*kappa+sqrt(pow(p,2)+4*pow(kappa,2)-4*(p-2)*kappa));
    // Rcout << "b:" << b  << std::endl;
    double scale = b/(b+2*kappa);
    double known = -p*0.5*(log(p)-log(b)) + 0.5 * (p-b);
    while(count<n){
      candidate = arma::randn(p).t();
      candidate.subvec( 0, p-2 ) *= sqrt(scale);
      candidate = arma::normalise(candidate);
      cand = candidate(p-1);
      cand2 = resize(candidate,1 ,p-1);
      unif = arma::randu<double>();
      ratio = known - sum(pow(cand2,2),1)*kappa + p*0.5*log(sum(pow(cand2,2),1)/scale+cand*cand);
      if(log(unif)<ratio(0)){
        A.row(count) = candidate;
        count += 1;
      }
      Nt += 1;
    }
  }
  arma::mat Q,R;
  qr(Q,R,mu);
  A = A*join_rows(Q.cols(1, p-1),mu).t();
  // Rcout << n <<"/" << Nt << "% accepted." << std::endl;
  return A;
}

//' @title Random Sampling from a Mixture of Watson Distributions
//' @description \code{rmwat} generates a random sample from a mixture of multivariate Watson distributions.
//' @param n an integer giving the number of samples to draw.
//' @param weights a numeric vector with non-negative elements giving the mixture probabilities.
//' @param kappa a numeric vector giving the kappa parameters of the mixture components.
//' @param mu a numeric matrix with columns giving the mu parameters of the mixture components.
//' @param b a positive numeric hyper-parameter used in the sampling. If not a positive value is given, optimal choice of b is used, default: -10.
//' @return  A matrix with rows equal to the generated values.
//' @details The function generates samples from finite mixtures of Watson distributions,
//'          using adjusted BACG algorithm of Kent (2013) for the case of Watson distribution. The algorithm is of the
//'          rejection-sampling form.
//'
//'          Due to the speed of simulation, the underlyning C++ code does not contain any checks that would interupt the simulation
//'          if the user would try to do so. This is in general safe as with the optimal parameter b
//'          the acceptence probability is close to 100% (and increases with dimension).
//'          However, different choices of b may cause difficulties in acceptance and are not
//'          recomended mostly for big dimensions unless you know what you are doing!
//'          The optimal b is used if the input value is not suitable, i.e., is not positive (also the default case).
//' @examples
//'
//' ## simulate from Watson distribution
//' sample1 <- rmwat(n = 20, weights = 1, kappa = 20, mu = matrix(c(1,1,1),nrow = 3))
//'
//' ## simulate from a mixture of Watson distributions
//' sample2 <- rmwat(n = 20, weights = c(0.5,0.5), kappa = c(-200,-200),
//'                             mu = matrix(c(1,1,1,-1,1,1),nrow = 3))
//' @rdname rmwat
//' @references Kent J.T., Ganeiber A.M. and Mardia K.V. (2013). A new method to simulate the Bingham and related distributions
//'   in directional data analysis with applications \url{http://arxiv.org/pdf/1310.8110v1.pdf}
//' @export
// [[Rcpp::export]]
NumericMatrix rmwat(int n, arma::vec &weights, arma::vec kappa, arma::mat &mu, double b = -10){
  weights = arma::normalise(weights, 1);
  int p = mu.n_rows;
  int K = mu.n_cols;
  arma::mat A(n, p);
  arma::uvec sample = RcppArmadillo::sample(arma::regspace<arma::uvec>(0, K-1), n, true, weights);
  int size;
  arma::uvec which;
  arma::vec mus;
  for(int i = 0; i < K; i++) {
    which = arma::find(sample==i);
    size = which.n_elem;
    // Rcout << size << std::endl;
    mus = mu.col(i);
    if(size>0){
      A.rows(which) = rwat(size, kappa(i), mus, b);
    }
  }
  sample = sample + 1;
  IntegerVector fac = wrap(sample);
  IntegerVector lev = seq(1,K);
  fac.attr("dim") = R_NilValue;
  fac.attr("levels") = as<CharacterVector>(lev);
  fac.attr("class") = "factor";
  
  NumericMatrix res = wrap(A);
  res.attr("id") = fac;
  res.attr("class") = "rmwat";
  return res;
}
